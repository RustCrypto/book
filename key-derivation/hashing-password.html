<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Password Hashing - The RustCrypto Book</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="Reference manual for the RustCrypto project">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">Introduction</a></li><li class="chapter-item expanded "><a href="../hashing-data/index.html"><strong aria-hidden="true">1.</strong> Data Hashing</a></li><li class="chapter-item expanded "><a href="../key-derivation/index.html"><strong aria-hidden="true">2.</strong> Key Derivation</a></li><li class="chapter-item expanded "><a href="../key-derivation/hashing-password.html" class="active"><strong aria-hidden="true">3.</strong> Password Hashing</a></li><li class="chapter-item expanded "><a href="../message-authentication/index.html"><strong aria-hidden="true">4.</strong> Message Authentication</a></li><li class="chapter-item expanded "><a href="../signing/index.html"><strong aria-hidden="true">5.</strong> Digital Signing</a></li><li class="chapter-item expanded "><a href="../encryption-asymmetric/index.html"><strong aria-hidden="true">6.</strong> Asymmetric Encryption</a></li><li class="chapter-item expanded "><a href="../encryption-symmetric/index.html"><strong aria-hidden="true">7.</strong> Symmetric Encryption</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="../glossary.html"><strong aria-hidden="true">8.</strong> Glossary</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The RustCrypto Book</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="password-hashing"><a class="header" href="#password-hashing">Password Hashing</a></h1>
<p>RustCrypto provides a number of <a href="https://en.wikipedia.org/wiki/Key_derivation_function#Password_hashing">password hash functions</a>, which takes arbitrary data (a password)
and produces a hash. This hash is typically stored in a database, along with the hash function
parameters used to create it. When an unknown password is received, it is hashed with the same
function and compared with the stored value.</p>
<p>Technically, password hash functions are &quot;key derivation functions&quot; which take a secret key (the
real password) and turn it into another secret key (the hash stored in the database).</p>
<p>RustCrypto password hashes implement the <a href="https://docs.rs/password-hash/latest/password_hash/trait.PasswordHasher.html"><code>PasswordHasher</code></a> and <a href="https://docs.rs/password-hash/latest/password_hash/trait.PasswordVerifier.html"><code>PasswordVerifier</code></a> traits, which
provide the hash and check interfaces. These come from the <a href="https://docs.rs/password-hash/latest/password_hash/"><code>password-hash</code></a> crate, and are always
reexported in the hash algorithm's crate root.</p>
<h2 id="what-should-i-use"><a class="header" href="#what-should-i-use">What should I use?</a></h2>
<p>OWASP puts out a <a href="https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html">Password Storage Cheat Sheet</a>, which at time of writing lists the following order
of preferences:</p>
<ol>
<li>Argon2id with minimum 19 MiB memory, two iterations, and one degree of parallelism</li>
<li>Scrypt with a memory cost parameter of 2<sup>17</sup>, block size of 8, and 1 degree of
parallelism</li>
<li>Bcrypt with a minimum work factor of 10 and a password limit of 72 bytes</li>
<li>If FIPS-140 compliance is required, PBKDF2 with a minimum work factor of 600,000 and a SHA-256
internal hash function</li>
</ol>
<p>You don't need to worry about setting these parameters; the default implementations match the
recommendations.</p>
<pre><code class="language-rust noplaypen"><span class="boring">fn main() {
</span>use argon2::{Argon2, PasswordHasher, PasswordVerifier, password_hash::Salt};

let password = &quot;password&quot;;

// This is the b64 hash of &quot;bad salt!&quot; for demo only: don't do this! Instead use:
// let salt = SaltString::generate(&amp;mut OsRng);
let salt_str = &quot;YmFkIHNhbHQh&quot;;
let salt: Salt = salt_str.try_into().unwrap();

let argon2 = Argon2::default();
let hash = argon2.hash_password(password.as_bytes(), salt).unwrap();

// This is the hash we will store. Notice our salt string is included, as well as parameters:
// version 0x13 (19), memory 19456KiB (19 MiB), 2 iterations (time), parallelism 1
let expected =
    &quot;$argon2id$v=19$m=19456,t=2,p=1$YmFkIHNhbHQh$DqHGwv6NQV0VcaJi7jeF1E8IpfMXmXcpq4r2kKyqpXk&quot;;
//   ^ hash ^ parameters            ^ salt       ^ combined hash

assert_eq!(expected, hash.to_string());

// The verifier reads the salt and the parameters from the hash and verifies the result is equal
Argon2::default().verify_password(password.as_bytes(), &amp;hash).expect(&quot;invalid password&quot;);
<span class="boring">}</span></code></pre>
<p>Sometimes it may be necessary to support the verification of passwords that were hashed with
different algorithms or parameters. This can be done using the traits in <code>password_hash</code>:</p>
<pre><code class="language-rust noplaypen"><span class="boring">fn main() {
</span>use password_hash::{PasswordHash, PasswordVerifier};

use argon2::Argon2;
use pbkdf2::Pbkdf2;
use scrypt::Scrypt;

// Can be: `$argon2`, `$pbkdf2`, or `$scrypt`
let hash_string =
    &quot;$argon2id$v=19$m=19456,t=2,p=1$YmFkIHNhbHQh$DqHGwv6NQV0VcaJi7jeF1E8IpfMXmXcpq4r2kKyqpXk&quot;;
let input_password = &quot;password&quot;;

let password_hash = PasswordHash::new(&amp;hash_string).expect(&quot;invalid password hash&quot;);

// Trait objects for algorithms to support
let algs: &amp;[&amp;dyn PasswordVerifier] = &amp;[&amp;Argon2::default(), &amp;Pbkdf2, &amp;Scrypt];

password_hash.verify_password(algs, input_password).expect(&quot;invalid password&quot;);
<span class="boring">}</span></code></pre>
<h2 id="differences-with-standard-hash-functions"><a class="header" href="#differences-with-standard-hash-functions">Differences with Standard Hash Functions</a></h2>
<p>Compared with <a href="hashing-data/README.html">standard hash functions</a>, password hashes have a few features
that make them well suited to this purpose:</p>
<h3 id="salt"><a class="header" href="#salt">Salt</a></h3>
<p>&quot;Salt&quot; is random data that gets concatenated with the password before going through the hash
function. This data needs to be different for each password hashed, but gets stored with the output
hash and reused during verification.</p>
<p>This roughly looks like the following:</p>
<pre><code>storage:

    per-entry random salt -\
                            \
    plaintext password -&gt; argon2 -&gt; database entry


verification:

                     /-- hash ---------------------------\
    database entry -|             argon2 -&gt; test hash -&gt; compare
                     \            /  /
                      \-- salt --/  /
                                   /
    test password ----------------/

</code></pre>
<p>See <a href="#appendix-why-salt">Why Salt?</a> in the appendix for an illustration of why this is necessary.</p>
<h3 id="slowness"><a class="header" href="#slowness">Slowness</a></h3>
<p>While hashes like SHA-256 are meant to be fast, password hashes are meant to be slow. This is to
help slow down brute forcing, where an attacker tries hashing a wide variety of common passwords
with a known salt to try to compute a known hash.</p>
<p>As mentioned in <a href="#what-should-i-use">What should I use?</a>, password hashing algorithms have parameters that can control
how slow or fast they are to solve. The defaults recommended by OWASP provide a good balance of high
security without being nonperformant.</p>
<h3 id="a-note-on-pepper"><a class="header" href="#a-note-on-pepper">A Note on Pepper</a></h3>
<p>Peppering is the process of encrypting hashed passwords with a secret key before storing in the
database. For example:</p>
<pre><code>storage:

    per-entry random salt -\
                            \
    plaintext password -&gt; argon2 -&gt; aes256-gcm encrypt -&gt; database entry
                                     /
    per-database secret key --------/


verification:

    per-database secret key ----\
                                 \         /-- hash ---------------------------\
    database entry -&gt; aes256-gem decrypt -|             argon2 -&gt; test hash -&gt; compare
                                           \            /  /
                                            \-- salt --/  /
                                                         /
    test password --------------------------------------/

</code></pre>
<p>OWSAP now suggests this process since it means that even if an attacker has access to the database
table, they cannot do anything with it unless they also have the encryption key (stored separately).</p>
<p>Peppering is not considered part of password hashing functions.</p>
<h2 id="appendix-why-salt"><a class="header" href="#appendix-why-salt">Appendix: Why Salt?</a></h2>
<p>What purpose does salting passwords solve? To start, imagine that we use SHA-256 to hash our
password:</p>
<blockquote>
<p><strong>WARNING</strong>: DO NOT use SHA-256 as a password hashing algorithm. We use it in this example only
because it is easy to understand. See the <a href="#what-should-i-use">What should I use?</a> section at the top of this page for
better options.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust editable edition2021"><span class="boring">fn main() {
</span><span class="boring">use sha2::{Sha256, Digest};
</span><span class="boring">use data_encoding::HEXLOWER;
</span>let input = &quot;password&quot;;

let mut hash = Sha256::new();
hash.update(input.as_bytes());
let result = hash.finalize();

println!(&quot;Hash: {}&quot;, HEXLOWER.encode(&amp;result));
<span class="boring">}</span></code></pre></pre>
<p>This prints <code>5e884898da...</code>, which we would store in our database.</p>
<p>Now some security event happens, and our database with all password hashes gets leaked. Now, the
public has this information:</p>
<pre><code>+----------+------------+
| username | pw_sha256  |
+----------+------------+
| ferris   | 5e884898da | &lt;- note this hash
| curie    | 437dd76609 |
| turing   | fc3a03a63b |
+----------+------------+
</code></pre>
<p>An attacker is prepared, and has precalculated a table of common password hashes:</p>
<pre><code>+----------+------------+
| input    | sha_256    |
+----------+------------+
| 1234     | 03ac674216 |
| abcd     | 84e73dc50f |
| password | 5e884898da | &lt;- note this hash
+----------+------------+
</code></pre>
<p>Bingo! user <code>ferris</code> has password hash <code>5e884898da</code>, which means the password <code>password</code> will work
to access ferris's account. The user is now compromised!</p>
<p>This is a simple version of a rainbow attack. To prevent this, we do what is called &quot;salting&quot;. This
means that we pick a random salt that we store with the password in the database, and hash that salt
with the input password when we want to check it:</p>
<pre><code>+----------+------------------------+
| username | pw                     |
+----------+------------------------+
| ferris   | $sha2$salty$d878e396b9 | # user's password is 'password'
| curie    | $sha2$spice$036ecfef69 |
| turing   | $sha2$spice$701f72c284 |
| lovelace | $sha2$sugar$a92ec3b280 | # user's password is also 'password'
+----------+------------------------+
</code></pre>
<p>Notice how no hashes from the attacker's list appear in our new password table, and that even though
two users have the same password, their hashes are different. This means that an attacker can no
longer look up a hash directly, and instead has to waste time calculating each possible input!</p>
<p>A salt function with SHA-256 would roughly look like:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021"><span class="boring">fn main() {
</span><span class="boring">use sha2::{Sha256, Digest};
</span><span class="boring">use data_encoding::HEXLOWER;
</span>// Input from the user
let input = &quot;password&quot;;

// That user's salt, stored in the database
let salt = &quot;salty&quot;;
let to_hash = format!(&quot;{salt}{input}&quot;);

// Compute salt+input hash
let mut hash = Sha256::new();
hash.update(to_hash.as_bytes());
let result = hash.finalize();
let digest = HEXLOWER.encode(&amp;result);

println!(&quot;Hash: {digest}&quot;);

// Hash of salt+password in the database
let stored_value = &quot;d878e396b9&quot;;
assert_eq!(stored_value, &amp;digest[..10]);
<span class="boring">}</span></code></pre></pre>
<p>The <a href="https://docs.rs/password-hash/latest/password_hash/trait.PasswordHasher.html"><code>PasswordHasher</code></a> trait makes sure that salt is always used when hashing passwords.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../key-derivation/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../message-authentication/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../key-derivation/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../message-authentication/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
